# Date: 04/22

## Coding Test Prep:
Greedy: https://programmers.co.kr/learn/courses/30/lessons/42883    
보자마자 들었던 생각인 combiations를 이용하여 모든 가능한 조합이 찾고 거기서 가장 큰 수를 리턴하는 방식으로 접근하였다.  
그러나 combinations은 총 O(k (n choose k)) 을 가지는데 여기서 n은 최대 1,000,000 까지 커진다. 그렇다면 최대 100억이 넘는   
연산이 실행되는데 이 경우에는 무조건 실패한다고 볼수있다.   

두번째의 접근 방법은 이 문제에서의 조합은 중복조합이 없기에 (ex: "123" && k = 2 ==> 12,13,23 만이 가능 옵션. 32,31은 포함되지 않는다.)  
그렇기에 len(s)-k 이전에 있는 인덱스에서 가장 큰수를 찾아서 조합하는 방식을 사용해보자.   

결국 두번째의 접근 방법으로 풀긴 했으나 중간중간 실수가 너무 많았다. 정말 단순한 접근이 필요했던 문제인데 그걸 제대로 하지 못한 듯 하다.   
시간의 절약을 위해 현재의 맥시멈이 9일 경우 for문을 끊는 문을 추가해야만 성공하는 문제이다. (n 이 최대 1,000,000 이기 때문에 만약   
99만9999 일 경우 계속해서 연산을 하게되는데 시간이 너무 오래걸리게 된다.) 좀 더 단순하게 기본에 입각해 생각하자.  


Complete Search: https://programmers.co.kr/learn/courses/30/lessons/42842  https://programmers.co.kr/learn/courses/30/lessons/12903  

Kakao: https://programmers.co.kr/learn/courses/30/lessons/17682  

위의 세 문제들은 어려움 없이 30~60 사이에 반드시 풀수 있던거 같다.   

Kakao 2021 blind 순위 검색: https://programmers.co.kr/learn/courses/30/lessons/72412   
레벨2라고는 믿기지 않을 만큼 어려웠다.. 앵간한 효율성 문제들이 그렇듯 이 문제도  
당연하게 어느정도는 특정 알고리즘을 모르면 못푸는 종류인듯 하다. (확실한건 아님)  

첫번째로 글들을 보며 들었던 의문인 combinations을 사용한 가능 옵션 수 확인이    
2,3중 for문을 이용한 조합 만들기 보다 빠른 이유는 생각해보면 간단하다. 16*5*50000가   
50000*100000보다 한참 작은 수 이다. 내 경우에는 defaultdict를 이용해서 좀 더 편하게 접근할수 있었으나   
기존의 dict를 이용해 푼 경우도 있었는데 이경우는 어떤 원리인지 확인이 필요할듯 하다.   
  
이렇게 가능한 옵션을 잡아두고 나면 더 중요한 비교를 해야하는데 이미 저 위에서 만든 옵션의 토탈이 최악의 경우    
4,000,000 이다... 즉 저 양을 linear 를 넘어서는 비교횟수가 되면 실패한다는 얘기. 그렇기에 for 문 안에서 더 작아져야 하는데    
그렇기에 필요한게 binary search이다. 기본적으로 binary search는 log(n)의 시간 복잡도를 가지기에    
이부분에서 n*log(n) 즉 최악의 경우 100,000*(4,000,000) ~= 660206 회의 연산이 필요해진다. 그러나 이는 위의 연산과는 합연산   
으로 계산되는 연산이기에 노 문제! 그러므로 효율성 검사를 통과할수 있게 된다.   

